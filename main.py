import asyncio
import json
import logging
import re
import os
from datetime import datetime, time
from bs4 import BeautifulSoup
import aiohttp
from telegram import Update, Bot, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')  # –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ –∑–∞–≥—Ä—É–∑–∫—É –∏–∑ .env
CHECK_INTERVAL_HOURS = 3  # –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ 3 —á–∞—Å–∞
TARGET_PRICE = 1400.0
BASE_URL = "https://dns-shop.by"
SEARCH_URL = "https://dns-shop.by/ru/category/17a89aab16404e77/videokarty/"
DATA_FILE = 'graphic_cards.json'
NIGHT_MODE_FILE = 'night_mode.json'

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class NightModeManager:
    def __init__(self, filename=NIGHT_MODE_FILE):
        self.filename = filename
        self.ensure_file_exists()

    def ensure_file_exists(self):
        """–°–æ–∑–¥–∞–µ—Ç —Ñ–∞–π–ª –Ω–æ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞, –µ—Å–ª–∏ –æ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"""
        if not os.path.exists(self.filename):
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump({"enabled": False}, f, indent=2, ensure_ascii=False)
            logger.info(f"Created night mode file: {self.filename}")

    def load_night_mode(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–æ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞"""
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.error(f"Error loading night mode: {e}")
            return {"enabled": False}

    def save_night_mode(self, data):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–æ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞"""
        try:
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error saving night mode: {e}")

    def is_night_mode_enabled(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –≤–∫–ª—é—á–µ–Ω –ª–∏ –Ω–æ—á–Ω–æ–π —Ä–µ–∂–∏–º"""
        return self.load_night_mode()["enabled"]

    def toggle_night_mode(self, user_id):
        """–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –Ω–æ—á–Ω–æ–π —Ä–µ–∂–∏–º"""
        data = self.load_night_mode()
        data["enabled"] = not data["enabled"]
        data["last_toggled_by"] = user_id
        data["last_toggled_at"] = datetime.now().isoformat()
        self.save_night_mode(data)
        return data["enabled"]

    def is_night_time(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–µ–π—á–∞—Å –Ω–æ—á–Ω–æ–µ –≤—Ä–µ–º—è (—Å 00:00 –¥–æ 08:00)"""
        now = datetime.now().time()
        night_start = time(0, 0)  # 00:00
        night_end = time(8, 0)    # 08:00
        
        if night_start <= now <= night_end:
            return True
        return False

    def should_send_notifications(self):
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
        if not self.is_night_mode_enabled():
            return True
        
        # –ï—Å–ª–∏ –Ω–æ—á–Ω–æ–π —Ä–µ–∂–∏–º –≤–∫–ª—é—á–µ–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è
        if self.is_night_time():
            logger.info("Night mode active: not sending notifications")
            return False
        return True

class DataManager:
    def __init__(self, filename=DATA_FILE):
        self.filename = filename
        self.ensure_file_exists()

    def ensure_file_exists(self):
        """–°–æ–∑–¥–∞–µ—Ç —Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö, –µ—Å–ª–∏ –æ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"""
        if not os.path.exists(self.filename):
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump({"graphic_cards": {}}, f, indent=2, ensure_ascii=False)
            logger.info(f"Created data file: {self.filename}")

    def load_data(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞"""
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.error(f"Error loading data: {e}")
            return {"graphic_cards": {}}

    def save_data(self, data):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–∞–π–ª"""
        try:
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error saving data: {e}")

    def get_product_key(self, title, price):
        """–°–æ–∑–¥–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á –¥–ª—è —Ç–æ–≤–∞—Ä–∞"""
        return f"{title}_{price}"

class DNSParser:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }

    async def fetch_page(self, session, url):
        try:
            async with session.get(url, headers=self.headers) as response:
                if response.status == 200:
                    return await response.text()
                else:
                    logger.error(f"HTTP error {response.status} for {url}")
                    return None
        except Exception as e:
            logger.error(f"Error fetching {url}: {e}")
            return None

    def parse_price(self, price_text):
        """–ü–∞—Ä—Å–∏—Ç —Ü–µ–Ω—É –∏–∑ —Ç–µ–∫—Å—Ç–∞, —É—á–∏—Ç—ã–≤–∞—è –¥–µ—Å—è—Ç–∏—á–Ω—ã–µ —á–∏—Å–ª–∞"""
        try:
            # –£–¥–∞–ª—è–µ–º –≤—Å–µ –Ω–µ—á–∏—Å–ª–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã, –∫—Ä–æ–º–µ —Ç–æ—á–∫–∏ –∏ –∑–∞–ø—è—Ç–æ–π
            cleaned_text = re.sub(r'[^\d,.]', '', price_text)
            
            # –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ float
            cleaned_text = cleaned_text.replace(',', '.')
            
            # –£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ —Ç–æ—á–∫–∏ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—É—é)
            if cleaned_text.count('.') > 1:
                parts = cleaned_text.split('.')
                cleaned_text = parts[0] + '.' + ''.join(parts[1:])
            
            return float(cleaned_text)
        except (ValueError, AttributeError) as e:
            logger.warning(f"Error parsing price '{price_text}': {e}")
            return None

    def parse_products(self, html, selectors):
        if not html:
            return []
            
        soup = BeautifulSoup(html, 'html.parser')
        products = soup.select(selectors['product'])
        results = []
        
        for product in products:
            try:
                title_elem = product.select_one(selectors['title'])
                price_elem = product.select_one(selectors['price'])
                image_elem = product.select_one(selectors['image'])
                
                if not all([title_elem, price_elem, image_elem]):
                    continue

                title = title_elem.text.strip()
                price_text = price_elem.text.strip()
                
                # –ü–∞—Ä—Å–∏–º —Ü–µ–Ω—É —Å —É—á–µ—Ç–æ–º –¥–µ—Å—è—Ç–∏—á–Ω—ã—Ö —á–∏—Å–µ–ª
                price = self.parse_price(price_text)
                if price is None:
                    continue
                
                # –ü–æ–ª—É—á–∞–µ–º URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                image_url = image_elem.get('src', '') or image_elem.get('data-src', '')
                if image_url and not image_url.startswith('http'):
                    image_url = BASE_URL + image_url

                if price < TARGET_PRICE:
                    results.append({
                        'title': title,
                        'price': price,
                        'price_text': price_text.strip(),
                        'image_url': image_url,
                        'timestamp': datetime.now().isoformat()
                    })
            except (ValueError, AttributeError, TypeError) as e:
                logger.warning(f"Error parsing product: {e}")
                continue
        
        return results

    async def parse_all_pages(self, url, selectors):
        async with aiohttp.ClientSession() as session:
            all_products = []
            page = 1
            
            while True:
                paginated_url = f"{url}?avail=now%2Ctod%2Ctom%2Clat%2Cinw%2Cuna&sqctg=rtx+5060&page={page}"
                logger.info(f"Parsing page {page}: {paginated_url}")
                
                html = await self.fetch_page(session, paginated_url)
                if not html:
                    break

                products = self.parse_products(html, selectors)
                if not products:
                    logger.info(f"No more products found on page {page}")
                    break

                all_products.extend(products)
                page += 1
                await asyncio.sleep(1)
            
            logger.info(f"Found {len(all_products)} products below {TARGET_PRICE} BYN")
            return all_products

class SubscriptionManager:
    def __init__(self, filename='subscriptions.json'):
        self.filename = filename
        self.ensure_file_exists()

    def ensure_file_exists(self):
        if not os.path.exists(self.filename):
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump({"users": []}, f, indent=2, ensure_ascii=False)

    def load_subscriptions(self):
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return {"users": []}

    def save_subscriptions(self, data):
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def add_user(self, user_id):
        data = self.load_subscriptions()
        if user_id not in data['users']:
            data['users'].append(user_id)
            self.save_subscriptions(data)
            logger.info(f"User {user_id} subscribed")
            return True
        return False

    def get_all_users(self):
        return self.load_subscriptions()['users']

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
parser = DNSParser()
subscription_manager = SubscriptionManager()
data_manager = DataManager()
night_mode_manager = NightModeManager()

SELECTORS = {
    'product': 'li.catalog-category-products__product',
    'title': 'a.catalog-category-product__title',
    'price': 'div.catalog-product-purchase__current-price',
    'image': 'div.catalog-category-product__image img'
}

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏
def get_main_keyboard():
    keyboard = [
        [KeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å")],
        [KeyboardButton("üìä –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏")],
        [KeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
        [KeyboardButton("üåô –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º")]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

async def compare_products(current_products):
    """–°—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ —Ç–æ–≤–∞—Ä—ã —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º–∏ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
    saved_data = data_manager.load_data()
    saved_products = saved_data.get('graphic_cards', {})
    
    current_keys = set()
    new_products = []
    updated_products = []
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª—é—á–∏ –¥–ª—è —Ç–µ–∫—É—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤
    for product in current_products:
        key = data_manager.get_product_key(product['title'], product['price'])
        current_keys.add(key)
        
        if key not in saved_products:
            # –ù–æ–≤—ã–π —Ç–æ–≤–∞—Ä
            new_products.append(product)
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ
            saved_products[key] = {
                'title': product['title'],
                'price': product['price'],
                'price_text': product['price_text'],
                'image_url': product['image_url'],
                'first_seen': datetime.now().isoformat(),
                'last_updated': datetime.now().isoformat()
            }
        else:
            # –¢–æ–≤–∞—Ä —É–∂–µ –µ—Å—Ç—å, –æ–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
            saved_products[key]['last_updated'] = datetime.now().isoformat()
            updated_products.append(product)
    
    # –ò—â–µ–º —É–¥–∞–ª–µ–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
    removed_products = []
    saved_keys = set(saved_products.keys())
    removed_keys = saved_keys - current_keys
    
    for key in removed_keys:
        removed_products.append(saved_products[key])
        # –£–¥–∞–ª—è–µ–º –∏–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö
        del saved_products[key]
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    saved_data['graphic_cards'] = saved_products
    data_manager.save_data(saved_data)
    
    return {
        'new': new_products,
        'updated': updated_products,
        'removed': removed_products
    }

async def send_product_message(bot, user_id, product, message_type="new"):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–æ–≤–∞—Ä–µ"""
    try:
        if message_type == "new":
            caption = (
                f"üÜï –ù–û–í–´–ô –¢–û–í–ê–†\n"
                f"üéÆ {product['title']}\n"
                f"üí∞ –¶–µ–Ω–∞: {product['price_text']}\n"
                f"‚è∞ –î–æ–±–∞–≤–ª–µ–Ω: {datetime.now().strftime('%H:%M %d.%m.%Y')}"
            )
        elif message_type == "removed":
            caption = (
                f"‚ùå –¢–û–í–ê–† –£–î–ê–õ–ï–ù\n"
                f"üéÆ {product['title']}\n"
                f"üí∞ –¶–µ–Ω–∞: {product['price_text']}\n"
                f"‚è∞ –£–¥–∞–ª–µ–Ω: {datetime.now().strftime('%H:%M %d.%m.%Y')}"
            )
        else:
            return
        
        await bot.send_photo(
            chat_id=user_id,
            photo=product['image_url'],
            caption=caption
        )
        await asyncio.sleep(0.5)
        
    except Exception as e:
        logger.error(f"Error sending {message_type} product to {user_id}: {e}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user = update.effective_user
    night_mode_status = "–≤–∫–ª—é—á–µ–Ω" if night_mode_manager.is_night_mode_enabled() else "–≤—ã–∫–ª—é—á–µ–Ω"
    
    welcome_text = (
        f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! üëã\n\n"
        "–Ø –±–æ—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ–∫–∞—Ä—Ç –Ω–∞ DNS-Shop.\n"
        f"–Ø –±—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–∞—Ö –¥–µ—à–µ–≤–ª–µ {TARGET_PRICE} BYN.\n\n"
        f"üìä –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏: {CHECK_INTERVAL_HOURS} —á–∞—Å–∞\n"
        f"üåô –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º: {night_mode_status}\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start_mail - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É\n"
        "/check_now - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞\n"
        "/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è\n"
        "/night_mode - –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–æ—á–Ω–æ–π —Ä–µ–∂–∏–º\n"
        "–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ ‚¨áÔ∏è"
    )
    await update.message.reply_text(welcome_text, reply_markup=get_main_keyboard())

async def start_mail(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start_mail"""
    user_id = update.effective_user.id
    if subscription_manager.add_user(user_id):
        await update.message.reply_text(
            f"‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É! –ë—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–∞—Ö –¥–µ—à–µ–≤–ª–µ {TARGET_PRICE} BYN.",
            reply_markup=get_main_keyboard()
        )
    else:
        await update.message.reply_text(
            "‚ÑπÔ∏è –í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É.",
            reply_markup=get_main_keyboard()
        )

async def check_now(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /check_now"""
    user_id = update.effective_user.id
    users = subscription_manager.get_all_users()
    
    if user_id not in users:
        await update.message.reply_text(
            "‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É. –°–Ω–∞—á–∞–ª–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start_mail",
            reply_markup=get_main_keyboard()
        )
        return
    
    await update.message.reply_text(
        "üîç –ó–∞–ø—É—Å–∫–∞—é –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.",
        reply_markup=get_main_keyboard()
    )
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É
    products = await parser.parse_all_pages(SEARCH_URL, SELECTORS)
    changes = await compare_products(products)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    sent_new = 0
    sent_removed = 0
    
    for product in changes['new']:
        await send_product_message(context.bot, user_id, product, "new")
        sent_new += 1
    
    for product in changes['removed']:
        await send_product_message(context.bot, user_id, product, "removed")
        sent_removed += 1
    
    summary = []
    if sent_new > 0:
        summary.append(f"üÜï –ù–æ–≤—ã—Ö: {sent_new}")
    if sent_removed > 0:
        summary.append(f"‚ùå –£–¥–∞–ª–µ–Ω–Ω—ã—Ö: {sent_removed}")
    if not summary:
        summary.append("‚ÑπÔ∏è –ò–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ")
    
    await update.message.reply_text(
        f"‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:\n" + "\n".join(summary),
        reply_markup=get_main_keyboard()
    )

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è"""
    data = data_manager.load_data()
    products_count = len(data.get('graphic_cards', {}))
    
    night_mode_status = "–≤–∫–ª—é—á–µ–Ω" if night_mode_manager.is_night_mode_enabled() else "–≤—ã–∫–ª—é—á–µ–Ω"
    night_time_status = "–Ω–æ—á–Ω–æ–µ –≤—Ä–µ–º—è" if night_mode_manager.is_night_time() else "–¥–Ω–µ–≤–Ω–æ–µ –≤—Ä–µ–º—è"
    
    await update.message.reply_text(
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:\n\n"
        f"‚Ä¢ –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è —Ç–æ–≤–∞—Ä–æ–≤: {products_count}\n"
        f"‚Ä¢ –¶–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞: {TARGET_PRICE} BYN\n"
        f"‚Ä¢ –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏: {CHECK_INTERVAL_HOURS} —á–∞—Å–∞\n"
        f"‚Ä¢ –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º: {night_mode_status}\n"
        f"‚Ä¢ –°–µ–π—á–∞—Å: {night_time_status}",
        reply_markup=get_main_keyboard()
    )

async def night_mode(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –Ω–æ—á–Ω–æ–π —Ä–µ–∂–∏–º"""
    user_id = update.effective_user.id
    is_enabled = night_mode_manager.toggle_night_mode(user_id)
    
    status = "–≤–∫–ª—é—á–µ–Ω" if is_enabled else "–≤—ã–∫–ª—é—á–µ–Ω"
    description = (
        "üåô –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º –í–ö–õ–Æ–ß–ï–ù\n\n"
        "–° 00:00 –¥–æ 08:00 –±–æ—Ç –±—É–¥–µ—Ç:\n"
        "‚Ä¢ –ü–∞—Ä—Å–∏—Ç—å —Å–∞–π—Ç –∫–∞–∂–¥—ã–µ 3 —á–∞—Å–∞\n"
        "‚Ä¢ –û–±–Ω–æ–≤–ª—è—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö\n"
        "‚Ä¢ –ù–ï –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n\n"
        "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã —É—Ç—Ä–æ–º, –∫–æ–≥–¥–∞ –ø–æ—è–≤—è—Ç—Å—è –Ω–æ–≤—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è!"
        if is_enabled else
        "‚òÄÔ∏è –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º –í–´–ö–õ–Æ–ß–ï–ù\n\n"
        "–ë–æ—Ç –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è."
    )
    
    await update.message.reply_text(
        f"‚úÖ –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º {status}!\n\n{description}",
        reply_markup=get_main_keyboard()
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫"""
    text = update.message.text
    user_id = update.effective_user.id
    
    if text == "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–π—á–∞—Å":
        await check_now(update, context)
    elif text == "üìä –°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏":
        users = subscription_manager.get_all_users()
        if user_id in users:
            await update.message.reply_text(
                "‚úÖ –í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É\n\n"
                f"–¶–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞: {TARGET_PRICE} BYN\n"
                f"–°–ª–µ–¥—É—é—â–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ {CHECK_INTERVAL_HOURS} —á–∞—Å–∞",
                reply_markup=get_main_keyboard()
            )
        else:
            await update.message.reply_text(
                "‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É\n\n"
                f"–¶–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞: {TARGET_PRICE} BYN\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start_mail –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏",
                reply_markup=get_main_keyboard()
            )
    elif text == "üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
        await stats(update, context)
    elif text == "üåô –ù–æ—á–Ω–æ–π —Ä–µ–∂–∏–º":
        await night_mode(update, context)

async def send_notifications():
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–∞—Å—Å—ã–ª–∫–∏"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        if not night_mode_manager.should_send_notifications():
            logger.info("Skipping notifications due to night mode")
            return
            
        users = subscription_manager.get_all_users()
        if not users:
            logger.info("No subscribers found for automatic notification")
            return

        logger.info(f"Sending automatic notifications to {len(users)} users")
        products = await parser.parse_all_pages(SEARCH_URL, SELECTORS)
        changes = await compare_products(products)
        
        if not changes['new'] and not changes['removed']:
            logger.info("No changes detected for automatic notification")
            return

        # –°–æ–∑–¥–∞–µ–º Application –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
        application = Application.builder().token(TOKEN).build()
        
        for user_id in users:
            sent_new = 0
            sent_removed = 0
            
            for product in changes['new']:
                await send_product_message(application.bot, user_id, product, "new")
                sent_new += 1
            
            for product in changes['removed']:
                await send_product_message(application.bot, user_id, product, "removed")
                sent_removed += 1
            
            summary = []
            if sent_new > 0:
                summary.append(f"üÜï –ù–æ–≤—ã—Ö: {sent_new}")
            if sent_removed > 0:
                summary.append(f"‚ùå –£–¥–∞–ª–µ–Ω–Ω—ã—Ö: {sent_removed}")
            
            if summary:
                await application.bot.send_message(
                    chat_id=user_id,
                    text=f"üì¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ:\n" + "\n".join(summary),
                    reply_markup=get_main_keyboard()
                )
                    
    except Exception as e:
        logger.error(f"Error in automatic send_notifications: {e}")

async def scheduled_task():
    """–ó–∞–¥–∞—á–∞ –¥–ª—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏"""
    while True:
        try:
            # –í—Å–µ–≥–¥–∞ –ø–∞—Ä—Å–∏–º –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –±–∞–∑—É, –¥–∞–∂–µ –≤ –Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ
            logger.info("Starting scheduled parsing...")
            products = await parser.parse_all_pages(SEARCH_URL, SELECTORS)
            await compare_products(products)
            logger.info("Scheduled parsing completed")
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ
            await send_notifications()
            
            logger.info(f"Next check in {CHECK_INTERVAL_HOURS} hours")
            await asyncio.sleep(CHECK_INTERVAL_HOURS * 3600)
            
        except Exception as e:
            logger.error(f"Error in scheduled task: {e}")
            await asyncio.sleep(300)

def main():
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ç–æ–∫–µ–Ω–∞
    if not TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN not found in environment variables")
        logger.error("Please create .env file with TELEGRAM_BOT_TOKEN=your_token")
        return
    
    # –°–æ–∑–¥–∞–µ–º Application
    application = Application.builder().token(TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("start_mail", start_mail))
    application.add_handler(CommandHandler("check_now", check_now))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CommandHandler("night_mode", night_mode))
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, button_handler))

    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–µ
    loop = asyncio.get_event_loop()
    loop.create_task(scheduled_task())

    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    logger.info("Bot started with night mode and 3-hour interval")
    application.run_polling()

if __name__ == '__main__':
    main()